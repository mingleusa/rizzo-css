---
import Close from './icons/Close.astro';

interface Props {
  id?: string;
  title?: string;
  size?: 'sm' | 'md' | 'lg';
  open?: boolean;
  closeOnOverlayClick?: boolean;
  closeOnEscape?: boolean;
  class?: string;
}

const {
  id,
  title = 'Modal',
  size = 'md',
  open = false,
  closeOnOverlayClick = true,
  closeOnEscape = true,
  class: className = '',
} = Astro.props;

const modalId = id || `modal-${Math.random().toString(36).substr(2, 9)}`;
const sizeClass = size !== 'md' ? `modal--${size}` : '';
const classes = `modal ${sizeClass} ${className}`.trim();
---

<div
  class="modal__overlay"
  data-modal-overlay
  aria-hidden={open ? 'false' : 'true'}
  id={`${modalId}-overlay`}
></div>

<div
  class={classes}
  role="dialog"
  aria-modal="true"
  aria-labelledby={`${modalId}-title`}
  aria-hidden={open ? 'false' : 'true'}
  id={modalId}
  data-modal
>
  <div class="modal__header">
    <h2 id={`${modalId}-title`} class="modal__title">
      {title}
    </h2>
    <button
      type="button"
      class="modal__close"
      aria-label="Close modal"
      data-modal-close
    >
      <Close width={20} height={20} />
    </button>
  </div>

  <div class="modal__body">
    <slot />
  </div>

  <div class="modal__footer">
    <slot name="footer" />
  </div>
</div>

<script define:vars={{ modalId, closeOnEscape, closeOnOverlayClick, open }}>
  (function initModal() {
    // Wait for DOM to be ready
    const init = () => {
      const modal = document.querySelector(`#${modalId}`);
      if (!modal) {
        // Retry if modal not found yet
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', init);
          return;
        }
        return;
      }

      const overlay = document.querySelector(`#${modalId}-overlay`);
      const closeBtn = modal.querySelector('[data-modal-close]');
      const title = modal.querySelector(`#${modalId}-title`);

      if (!overlay || !closeBtn) return;
      
      // Ensure modal starts closed unless explicitly opened
      if (!open) {
        modal.setAttribute('aria-hidden', 'true');
        overlay.setAttribute('aria-hidden', 'true');
        modal.removeAttribute('data-open');
      }

      // Get focusable elements within modal
      const getFocusableElements = (container) => {
        const focusableSelectors = [
          'button:not([disabled])',
          'a[href]',
          'input:not([disabled])',
          'select:not([disabled])',
          'textarea:not([disabled])',
          '[tabindex]:not([tabindex="-1"])',
        ].join(', ');
        return Array.from(container.querySelectorAll(focusableSelectors));
      };

      /** Set focusables inside container to tabindex="-1" so they are not focusable when aria-hidden (a11y). */
      const setFocusablesInert = (container) => {
        getFocusableElements(container).forEach((el) => {
          if (el.getAttribute('tabindex') !== '-1') {
            el.setAttribute('data-modal-previous-tabindex', el.getAttribute('tabindex') || '0');
            el.setAttribute('tabindex', '-1');
          }
        });
      };

      /** Restore focusables so they are keyboard-focusable again. */
      const restoreFocusables = (container) => {
        container.querySelectorAll('[data-modal-previous-tabindex]').forEach((el) => {
          const prev = el.getAttribute('data-modal-previous-tabindex');
          el.setAttribute('tabindex', prev || '0');
          el.removeAttribute('data-modal-previous-tabindex');
        });
      };

      if (!open) setFocusablesInert(modal);

      let previousActiveElement = null;
      let focusTrapHandler = null;

      // Open modal
      const openModal = () => {
        previousActiveElement = document.activeElement;
        modal.setAttribute('aria-hidden', 'false');
        overlay.setAttribute('aria-hidden', 'false');
        modal.setAttribute('data-open', 'true');
        restoreFocusables(modal);

        // Focus first focusable element or close button
        const focusableElements = getFocusableElements(modal);
        const firstFocusable = focusableElements.length > 0 ? focusableElements[0] : closeBtn;
        if (firstFocusable) {
          setTimeout(() => firstFocusable.focus(), 0);
        }

        // Add focus trap
        focusTrapHandler = (e) => {
          if (modal.getAttribute('data-open') !== 'true') return;

          if (e.key === 'Escape' && closeOnEscape) {
            e.preventDefault();
            closeModal();
            return;
          }

          // Focus trap: Tab key
          if (e.key === 'Tab') {
            const focusableElements = getFocusableElements(modal);
            if (focusableElements.length === 0) return;

            const firstElement = focusableElements[0];
            const lastElement = focusableElements[focusableElements.length - 1];
            const activeElement = document.activeElement;

            if (e.shiftKey) {
              // Shift + Tab: move backwards
              if (activeElement === firstElement || !modal.contains(activeElement)) {
                e.preventDefault();
                lastElement.focus();
              }
            } else {
              // Tab: move forwards
              if (activeElement === lastElement || !modal.contains(activeElement)) {
                e.preventDefault();
                firstElement.focus();
              }
            }
          }
        };

        document.addEventListener('keydown', focusTrapHandler);
      };

      // Close modal
      const closeModal = () => {
        setFocusablesInert(modal);
        modal.setAttribute('aria-hidden', 'true');
        overlay.setAttribute('aria-hidden', 'true');
        modal.removeAttribute('data-open');

        // Remove focus trap
        if (focusTrapHandler) {
          document.removeEventListener('keydown', focusTrapHandler);
          focusTrapHandler = null;
        }

        // Return focus to previous element
        if (previousActiveElement) {
          previousActiveElement.focus();
          previousActiveElement = null;
        }
      };

      // Event listeners
      closeBtn.addEventListener('click', closeModal);

      if (closeOnOverlayClick) {
        overlay.addEventListener('click', (e) => {
          if (e.target === overlay) {
            closeModal();
          }
        });
      }

      // Initialize if open prop is true
      if (open) {
        setTimeout(() => openModal(), 0);
      }

      // Expose methods globally
      // Convert hyphens to underscores for valid JavaScript identifiers
      const modalIdAttr = modal.id.replace(/-/g, '_');
      window[`openModal_${modalIdAttr}`] = openModal;
      window[`closeModal_${modalIdAttr}`] = closeModal;
    };
    
    // Start initialization
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  })();
</script>
